<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="write something useful">
<meta property="og:type" content="website">
<meta property="og:title" content="Duncan's Blog">
<meta property="og:url" content="https://github.com/DuncanZhou/index.html">
<meta property="og:site_name" content="Duncan's Blog">
<meta property="og:description" content="write something useful">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Duncan's Blog">
<meta name="twitter:description" content="write something useful">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/DuncanZhou/"/>





  <title> Duncan's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Duncan's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/DuncanZhou/2017/05/18/OpenMPILearning/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="duncan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww1.sinaimg.cn/large/0060lm7Tgw1fakgrchk2xj303d03dmx4.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Duncan's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Duncan's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/18/OpenMPILearning/" itemprop="url">
                  OpenMPI学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-18T21:43:48+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###　配置<br>由于学校服务器上不允许随便装其他环境，所以用自己pc跑了程序.<br>学校服务器配置:10台物理机 每台机子2个核<br>PC:4核</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>1.OpenMPI<br>2.Python环境<br>3.nltk包安装<br>4.numpy环境<br>5.mpi4py</p>
<h3 id="代码程序"><a href="#代码程序" class="headerlink" title="代码程序"></a>代码程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">#-*-coding:utf-8-*-</div><div class="line">&apos;&apos;&apos;@author:duncan&apos;&apos;&apos;</div><div class="line">import re</div><div class="line">import os</div><div class="line">import math</div><div class="line">import time</div><div class="line">import sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</div><div class="line">import nltk</div><div class="line">from nltk.tokenize import word_tokenize</div><div class="line">from nltk.corpus import stopwords</div><div class="line">from nltk.stem import WordNetLemmatizer</div><div class="line">from mpi4py import MPI</div><div class="line">tweets_path = &apos;TestTweets/&apos;</div><div class="line"></div><div class="line">tags = 10</div><div class="line"></div><div class="line"></div><div class="line"># 公共通信变量</div><div class="line">comm = MPI.COMM_WORLD</div><div class="line"># 当前进程获取当前进程的id</div><div class="line">comm_rank = comm.Get_rank()</div><div class="line"># 获取整个通信结点的数量</div><div class="line">comm_size = comm.Get_size()</div><div class="line"></div><div class="line"># 计算一段文本中的tags,返回tag列表</div><div class="line">def GetTags(text):</div><div class="line">    twitter_stop_words = [&quot;from&quot;,&quot;TO&quot;,&quot;to&quot;,&quot;https&quot;,&quot;RT&quot;,&quot;URL&quot;,&quot;in&quot;,&quot;re&quot;,&quot;thank&quot;,&quot;thanks&quot;,&quot;today&quot;,&quot;yesterday&quot;,&quot;tomorrow&quot;,&quot;night&quot;,&quot;tonight&quot;,&quot;day&quot;,&quot;year&quot;,&quot;last&quot;,&quot;oh&quot;,&quot;yeah&quot;,&quot;amp&quot;]</div><div class="line">    &apos;&apos;&apos;</div><div class="line"></div><div class="line">    :param text: 文本</div><div class="line">    :return: 返回tag列表</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    # 首先针对推文中去除其他符号</div><div class="line">    text = re.sub(r&apos;[@|#][\d|\w|_]+|http[\w|:|.|/|\d]+&apos;,&quot;&quot;,text)</div><div class="line">    wordslist = []</div><div class="line">    if text == &quot;&quot; or text == None:</div><div class="line">        return []</div><div class="line"></div><div class="line">    # 利用nltk分词</div><div class="line">    words = word_tokenize(text)</div><div class="line">    for word in words:</div><div class="line">        # 去除停用词</div><div class="line">        if word not in (stopwords.words(&quot;english&quot;) and twitter_stop_words):</div><div class="line">            if(len(word) &gt; 2 and word.isalpha()):</div><div class="line">                wordslist.append(word.lower())</div><div class="line">    # 继续对词性进行标注</div><div class="line">    try:</div><div class="line">        pos = nltk.pos_tag(wordslist)</div><div class="line">    except Exception as e:</div><div class="line">        pos = []</div><div class="line">    if(len(pos) &lt; 1):</div><div class="line">        return []</div><div class="line">    tags = []</div><div class="line">    lemmatizer = WordNetLemmatizer()</div><div class="line">    for w in pos:</div><div class="line">        word = &quot;&quot;</div><div class="line">        # 是动词,做词性还原</div><div class="line">        if(w[1][0] == &apos;V&apos;):</div><div class="line">            word = lemmatizer.lemmatize(w[0],&apos;v&apos;)</div><div class="line">            tags.append(word)</div><div class="line">        # 是名词做词性还原</div><div class="line">        elif(w[1][0] == &quot;N&quot;):</div><div class="line">            word = lemmatizer.lemmatize(w[0])</div><div class="line">            tags.append(word)</div><div class="line">    i = 0</div><div class="line">    multicandidates = []</div><div class="line">    while(i &lt; len(pos) - 2):</div><div class="line">        phase = &quot;&quot;</div><div class="line">        # 动名词 | 动词 + 形容词 +名词</div><div class="line">        if (pos[i])[1][0] == &apos;V&apos; and (pos[i + 1][1][0] == &apos;N&apos; or (pos[i + 1][1][0] == &quot;J&quot; and pos[i + 2][1][0] == &quot;N&quot;)):</div><div class="line">            if pos[i + 1][1][0] == &apos;N&apos;:</div><div class="line">                suffix = lemmatizer.lemmatize(pos[i + 1][0],&apos;a&apos;)</div><div class="line">            else:</div><div class="line">                suffix = lemmatizer.lemmatize(pos[i + 1][0],&apos;n&apos;)</div><div class="line">            phase += lemmatizer.lemmatize((pos[i])[0],&apos;v&apos;) + &quot; &quot; + suffix</div><div class="line">            i = i + 2</div><div class="line">            while(i &lt; len(pos) and (pos[i])[1][0] == &apos;N&apos;):</div><div class="line">                phase += &quot; &quot; + lemmatizer.lemmatize((pos[i])[0])</div><div class="line">                i += 1</div><div class="line"></div><div class="line">            multicandidates.append(phase)</div><div class="line">        # 形容词　+ 名词</div><div class="line">        elif(pos[i][1][0] == &quot;J&quot; and pos[i + 1][1][0] == &quot;N&quot;):</div><div class="line">            if((i !=0 and pos[i - 1 ][1][0] != &quot;V&quot;) or i == 0):</div><div class="line">                phase +=lemmatizer.lemmatize((pos[i])[0],&quot;a&quot;) + &quot; &quot; + lemmatizer.lemmatize((pos[i + 1])[0])</div><div class="line">                i += 2</div><div class="line">                while(i &lt; len(pos) and (pos[i])[1][0] == &apos;N&apos;):</div><div class="line">                    phase += &quot; &quot; + lemmatizer.lemmatize((pos[i])[0],&quot;n&quot;)</div><div class="line">                    i += 1</div><div class="line">            multicandidates.append(phase)</div><div class="line">        else:</div><div class="line">            i += 1</div><div class="line">    if len(multicandidates) != 0:</div><div class="line">        tags += multicandidates</div><div class="line">    return tags</div><div class="line"></div><div class="line"></div><div class="line"># 计算words列表中词频</div><div class="line">def CalcTF(words,number):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    :param number: 限制返回的tag数量</div><div class="line">    :param words: 传入words的list列表</div><div class="line">    :return: 返回对应字典形式 &#123;tag:TF&#125;,最终返回列表</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    worddic = &#123;&#125;</div><div class="line">    # 先转换成集合</div><div class="line">    dic = set(words)</div><div class="line">    for word in dic:</div><div class="line">        TF = words.count(word)</div><div class="line">        worddic[word] = TF</div><div class="line">    # 将字典按照词频排序,取前10个</div><div class="line">    worddic = sorted(worddic.items(),key = lambda val:val[1],reverse=True)</div><div class="line">    return worddic[:number]</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    # text = &quot;how do i love you? Beautiful girls like eating cakes. I like dancing and swimming. How about you?he loves me? all we eat cakes.&quot;</div><div class="line">    # print CalcTF(GetTags(text),10)</div><div class="line"></div><div class="line">    flag = False</div><div class="line">    # 获取文件夹中用户总数及名称</div><div class="line">    names_list = os.listdir(tweets_path)</div><div class="line">    users_number = len(names_list)</div><div class="line">    if(comm_rank == 0):</div><div class="line">        print &quot;共%d个用户&quot; % users_number</div><div class="line">    block_size = math.ceil(users_number * 1.0 / comm_size)</div><div class="line">    # print &quot;block_size大小%d&quot; % block_size</div><div class="line">    start = i = int(comm_rank * block_size)</div><div class="line">    users_tags = []</div><div class="line">    start_time = time.time()</div><div class="line">    while(i &lt; block_size + start and i &lt; users_number):</div><div class="line">        with open(tweets_path + names_list[i],&apos;r&apos;) as f:</div><div class="line">            text = f.read()</div><div class="line">        # 得到某一用户的前n个tags,并有词频</div><div class="line">        user_tags = CalcTF(GetTags(text.decode(&quot;utf-8&quot;)),tags)</div><div class="line">        # print user_tags</div><div class="line">        users_tags += user_tags</div><div class="line">        i += 1</div><div class="line">        print &quot;已处理%d个用户&quot; % i</div><div class="line"></div><div class="line">    if(comm_rank == 0):</div><div class="line">        i = 1</div><div class="line">        while(i &lt; comm_size):</div><div class="line">            rev_tags = comm.recv(source=i)</div><div class="line">            # 合并起来</div><div class="line">            users_tags += rev_tags</div><div class="line">            i += 1</div><div class="line">            # print users_tags</div><div class="line">        # 写入文件</div><div class="line">        with open(&quot;/home/duncan/tags_tf&quot;,&quot;w&quot;) as f:</div><div class="line">            # 使得从第一行开始写</div><div class="line">            for tag in users_tags:</div><div class="line">                f.write(tag[0])</div><div class="line">                f.write(&quot;\t&quot;)</div><div class="line">                f.write(str(tag[1]))</div><div class="line">                f.write(&quot;\n&quot;)</div><div class="line">        print &quot;TF值写入完成&quot;</div><div class="line">        # 当对文件写入完成时发送广播</div><div class="line">        flag = True</div><div class="line">        comm.bcast(flag,root=0)</div><div class="line">    else:</div><div class="line">        # 除了0号进程外,其他进程发送数据,先发送自己的进程id</div><div class="line">        comm.send(users_tags,dest=0)</div><div class="line"></div><div class="line">    if(comm_rank != 0):</div><div class="line">        flag = comm.bcast(None,root=0)</div><div class="line"></div><div class="line">    # 当flag为True时继续向下计算</div><div class="line">    if(flag == True):</div><div class="line">        print &quot;process %d 开始计算idf&quot; % comm_rank</div><div class="line">        # 对保存好的文件中的TF词频tags继续计算IDF</div><div class="line">        with open(&quot;/home/duncan/tags_tf&quot;,&quot;r&quot;) as f:</div><div class="line">            lines = f.readlines()</div><div class="line">        # 每个进程结点需要处理的tags数</div><div class="line">        block_size = (int)(math.ceil(users_number * 1.0 / comm_size)) * tags</div><div class="line">        start = lineid = comm_rank * block_size</div><div class="line">        tags_tfidf = []</div><div class="line">        while(lineid &lt; block_size + start and lineid &lt; users_number * tags):</div><div class="line"></div><div class="line">            # 对lines[i]去计算它的idf,在其他用户tags中搜寻</div><div class="line">            user_id = int(math.ceil((lineid + 1) * 1.0 / tags))</div><div class="line">            # 所以该用户tags行标在[(user_id - 1) * tags,user_id * tags - 1]</div><div class="line">            search_rowid = 0</div><div class="line">            count = 1</div><div class="line">            while(search_rowid &lt; users_number * tags):</div><div class="line">                # 当在其中一个用户的tags中搜寻到后直接跳至下一个用户的tags</div><div class="line">                if(search_rowid &lt; (user_id - 1) * tags or search_rowid &gt; user_id * tags - 1):</div><div class="line">                    if((lines[search_rowid].split(&quot;\t&quot;))[0] == (lines[lineid].split(&quot;\t&quot;))[0]):</div><div class="line">                        count += 1</div><div class="line">                        # 跳到下一个用户tags开始处</div><div class="line">                        current_user_id = int(math.ceil((search_rowid + 1) * 1.0 / tags))</div><div class="line">                        search_rowid = current_user_id * tags</div><div class="line">                    else:</div><div class="line">                        search_rowid += 1</div><div class="line">                else:</div><div class="line">                    # 在所需要判断的用户的tags范围内,则跳出</div><div class="line">                    search_rowid = user_id * tags</div><div class="line">            idf = math.log(users_number * 1.0 / count,2)</div><div class="line">            # print count,idf</div><div class="line">            tags_tfidf.append(((lines[lineid].split(&quot;\t&quot;))[0],idf * int((lines[lineid].split(&quot;\t&quot;))[1])))</div><div class="line">            lineid += 1</div><div class="line"></div><div class="line">        end_time = time.time()</div><div class="line">        # 每个结点都处理完自己的用户推文</div><div class="line">        print &quot;process %d cost %f&quot; % (comm_rank,end_time - start_time)</div><div class="line"></div><div class="line">        # 该进程计算完其下所有用户的tags的tfidf</div><div class="line">        if(comm_rank == 0):</div><div class="line">            # 收集tags_tfidf</div><div class="line">            i = 1</div><div class="line">            while(i &lt; comm_size):</div><div class="line">                recv_tags = comm.recv(source = i)</div><div class="line">                tags_tfidf += recv_tags</div><div class="line">                i += 1</div><div class="line">            # 最终结果写入文件</div><div class="line">            with open(&quot;/home/duncan/tags_tfidf&quot;,&quot;w&quot;) as f:</div><div class="line">                for tag in tags_tfidf:</div><div class="line">                    f.write(tag[0])</div><div class="line">                    f.write(&quot;\t&quot;)</div><div class="line">                    f.write(str(tag[1]))</div><div class="line">                    f.write(&quot;\n&quot;)</div><div class="line">        else:</div><div class="line">            comm.send(tags_tfidf,dest=0)</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>1.48个用户,每个用户10个标签  加速比1.6左右<br>3.100个用户,每个用户10个标签,加速比(待跑)<br>3.1000个用户,每个用户10个标签,加速比(待跑)<br>4.10000个用户,每个用户10个标签,加速比(待跑)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/DuncanZhou/2017/05/16/No-Root Install mpi4py/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="duncan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww1.sinaimg.cn/large/0060lm7Tgw1fakgrchk2xj303d03dmx4.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Duncan's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Duncan's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/16/No-Root Install mpi4py/" itemprop="url">
                  在非root用户下安装mpi4py
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-16T09:52:51+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="step1"><a href="#step1" class="headerlink" title="step1:"></a>step1:</h3><p>安装mpi4py所需要的依赖包(python2.7版本/Cpython/Openmpi)<br>1.源码包安装Python2.7版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure prefix=&quot;#python安装目录(绝对路径)&quot;</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure></p>
<p>2.安装Cpython<br>使用当前用户目录下的python版本来进行安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/home/XXX/python27/bin/python setup.py install</div></pre></td></tr></table></figure></p>
<p>3.安装openmpi<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure prefix=&quot;#openmpi安装目录(绝对路径)&quot;</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure></p>
<h3 id="step3"><a href="#step3" class="headerlink" title="step3:"></a>step3:</h3><p>配置openmpi环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim ~/.bashrc</div><div class="line"># ~/.bashrc末尾添加</div><div class="line">export PATH=#openmpi的绝对路径/bin:$PATH</div><div class="line">soucre ~/.bashrc</div></pre></td></tr></table></figure></p>
<h3 id="step4"><a href="#step4" class="headerlink" title="step4:"></a>step4:</h3><p>安装mpi4py包(同Cpython包安装方法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/home/XXX/python27/bin/python setup.py install</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/DuncanZhou/2017/05/11/neo4j-developer-document/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="duncan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww1.sinaimg.cn/large/0060lm7Tgw1fakgrchk2xj303d03dmx4.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Duncan's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Duncan's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/11/neo4j-developer-document/" itemprop="url">
                  neo4j官方开发文档阅读记录
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-11T21:09:13+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>重新选择neo-4j官方的与python交互包，尝试了py2neo包后发现对neo4j了解还不够，很多操作只是浅尝辄止，所以，决定阅读neo4j的官方开发驱动包，并尝试学习Cypher语言，这对以后对人物关系的挖掘是有帮助的．</p>
</blockquote>
<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>neo-4j由两部分组成:relationship,label和property,label或者relationship中包含property,label与label之间形成关系.</p>
<h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h3><font color="red">2.1 Node语法</font><br>Cypher语言用()代表一个节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">()</div><div class="line">(matrix)</div><div class="line">(matrix:Movie)</div><div class="line">(matrix:Movie&#123;title:&quot;The Matrix&quot;,released:1997&#125;)</div></pre></td></tr></table></figure><br><br><font color="red">2.2 Relationship语法</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">--&gt;</div><div class="line">-[role]-&gt;</div><div class="line">-[:ACTED_IN]-&gt;</div><div class="line"># 关系的类型</div><div class="line">-[role:ACTED_IN]-&gt;</div><div class="line"># 关系的属性值,属性值可以是数组</div><div class="line">-[role:ACTED_IN &#123;role:[&quot;Neo&quot;]&#125;]-&gt;</div></pre></td></tr></table></figure><br><br><font color="red">2.3 Pattern语法</font><br>语法中有Node和Relationship<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(keanu:Person:Actor &#123;name:&quot;Keanu Reeves&quot;&#125;)</div><div class="line">-[role:ACTED_IN &#123;roles:[&quot;Neo&quot;]&#125;]-&gt;</div><div class="line">(matrix:Movie &#123;title:&quot;The matrix&quot;&#125;)</div></pre></td></tr></table></figure><br><br>保存结点关系path<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># acted_in中保存的就是path,有很多函数可以对path操作:nodes(path),rels(paht),len(path)</div><div class="line">acted_in = (:Person)-[:ACTED_IN]-&gt;(:Movie)</div></pre></td></tr></table></figure><br><br>创建数据及及结点关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE (:MOVIE &#123;title:&quot;The Matrix&quot;,released:1997&#125;)</div><div class="line">CREATE (p:Person &#123; name:&quot;Keanu Reeves&quot;, born:1964 &#125;)</div><div class="line">RETURN p</div><div class="line"># 创建关系</div><div class="line">CREATE (a:Person &#123; name:&quot;Tom Hanks&quot;,</div><div class="line">  born:1956 &#125;)-[r:ACTED_IN &#123; roles: [&quot;Forrest&quot;]&#125;]-&gt;(m:Movie &#123; title:&quot;Forrest Gump&quot;,released:1994 &#125;)</div><div class="line">CREATE (d:Person &#123; name:&quot;Robert Zemeckis&quot;, born:1951 &#125;)-[:DIRECTED]-&gt;(m)</div><div class="line">RETURN a,d,r,m</div></pre></td></tr></table></figure><br><br>匹配pattern<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MATCH(m:Movie)</div><div class="line">RETURN m</div><div class="line">MATCH(p:Person &#123;name:&quot;duncan&quot;&#125;)</div><div class="line">RETURN p</div><div class="line"># 匹配关系</div><div class="line">MATCH (p:Person &#123; name:&quot;Tom Hanks&quot; &#125;)-[r:ACTED_IN]-&gt;(m:Movie)</div><div class="line">RETURN m.title, r.roles</div></pre></td></tr></table></figure><br><br>添加节点并添加关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MATCH (p:Person &#123; name:&quot;Tom Hanks&quot; &#125;)</div><div class="line">CREATE (m:Movie &#123; title:&quot;Cloud Atlas&quot;,released:2012 &#125;)</div><div class="line">CREATE (p)-[r:ACTED_IN &#123; roles: [&apos;Zachry&apos;]&#125;]-&gt;(m)</div><div class="line">RETURN p,r,m</div></pre></td></tr></table></figure><br><br>更新结点属性,但不确定图中是否存在一个结点时(这样做的代价是开销很大),总之,使用MERGE,它没有找到就会创建.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MERGE (m:Movie &#123; title:&quot;Cloud Atlas&quot; &#125;)</div><div class="line">ON CREATE SET m.released = 2012</div><div class="line">RETURN m</div></pre></td></tr></table></figure><br><br><font color="red">2.4 where语法</font><br>以下两种写法相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MATCH (m:Movie)</div><div class="line">WHERE m.title = &quot;The Matrix&quot;</div><div class="line">RETURN m</div></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MATCH (m:Movie &#123; title: &quot;The Matrix&quot; &#125;)</div><div class="line">RETURN m</div></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MATCH (p:Person)-[r:ACTED_IN]-&gt;(m:Movie)</div><div class="line">WHERE p.name =~ &quot;K.+&quot; OR m.released &gt; 2000 OR &quot;Neo&quot; IN r.roles</div><div class="line">RETURN p,r,m</div></pre></td></tr></table></figure><br><br>where子句可以用关系来判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MATCH (p:Person)-[:ACTED_IN]-&gt;(m)</div><div class="line">WHERE NOT (p)-[:DIRECTED]-&gt;()</div><div class="line">RETURN p,m</div></pre></td></tr></table></figure><br><br>使用别名返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MATCH (p:Person)</div><div class="line">RETURN p, p.name AS name, upper(p.name), coalesce(p.nickname,&quot;n/a&quot;) AS nickname, &#123; name: p.name,</div><div class="line">  label:head(labels(p))&#125; AS person</div></pre></td></tr></table></figure><br><br>聚合函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MATCH (:Person)</div><div class="line">RETURN count(*) AS people</div></pre></td></tr></table></figure><br><br>排序和分页<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MATCH (a:Person)-[:ACTED_IN]-&gt;(m:Movie)</div><div class="line">RETURN a,count(*) AS appearances</div><div class="line">ORDER BY appearances DESC LIMIT 10;</div></pre></td></tr></table></figure><br><br>聚集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MATCH (m:Movie)&lt;-[:ACTED_IN]-(a:Person)</div><div class="line">RETURN m.title AS movie, collect(a.name) AS cast, count(*) AS actors</div></pre></td></tr></table></figure><br><br>合并两个结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MATCH (actor:Person)-[r:ACTED_IN]-&gt;(movie:Movie)</div><div class="line">RETURN actor.name AS name, type(r) AS acted_in, movie.title AS title</div><div class="line">UNION</div><div class="line">MATCH (director:Person)-[r:DIRECTED]-&gt;(movie:Movie)</div><div class="line">RETURN director.name AS name, type(r) AS acted_in, movie.title AS title</div></pre></td></tr></table></figure><br><br>with语法保留中间结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MATCH (person:Person)-[:ACTED_IN]-&gt;(m:Movie)</div><div class="line">WITH person, count(*) AS appearances, collect(m.title) AS movies</div><div class="line">WHERE appearances &gt; 1</div><div class="line">RETURN person.name, appearances, movies</div></pre></td></tr></table></figure><br><br>增加约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE</div></pre></td></tr></table></figure><br><br>创建索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE INDEX ON :Actor(name)</div></pre></td></tr></table></figure><br><br><font color="red">2.4 Cypher操作</font>

<p>更新操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MATCH (n &#123;name: &apos;John&apos;&#125;)-[:FRIEND]-(friend)</div><div class="line">WITH n, count(friend) AS friendsCount</div><div class="line">SET n.friendCount = friendsCount</div><div class="line">RETURN n.friendsCount</div></pre></td></tr></table></figure></p>
<p><font color="red">2.5 Cypher语法</font></p>
<p><font color="red">2.5.1 CASE语法</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MATCH (n)</div><div class="line">RETURN</div><div class="line">CASE n.eyes</div><div class="line">WHEN &apos;blue&apos;</div><div class="line">THEN 1</div><div class="line">WHEN &apos;brown&apos;</div><div class="line">THEN 2</div><div class="line">ELSE 3 END AS result</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MATCH (n)</div><div class="line">RETURN</div><div class="line">CASE</div><div class="line">WHEN n.eyes = &apos;blue&apos;</div><div class="line">THEN 1</div><div class="line">WHEN n.age &lt; 40</div><div class="line">THEN 2</div><div class="line">ELSE 3 END AS result</div></pre></td></tr></table></figure>
<p><font color="red">2.5.2 带参数查询</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MATCH (n:Person &#123; name: $name &#125;)</div><div class="line">RETURN n</div></pre></td></tr></table></figure></p>
<p><font color="red">2.5.3 定义正则表达式</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MATCH (n:Person)</div><div class="line"># regex在之前定义</div><div class="line">WHERE n.name =~ $regex</div><div class="line">RETURN n.name</div></pre></td></tr></table></figure></p>
<p><font color="red">2.5.4</font><br>用json数据创建结点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;props&quot; : &#123;</div><div class="line"> </div><div class="line">&quot;name&quot; : &quot;Andres&quot;,</div><div class="line"> </div><div class="line">&quot;position&quot; : &quot;Developer&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CREATE ($props)</div></pre></td></tr></table></figure></p>
<p>用json数据批量创建结点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;props&quot; : [ &#123;</div><div class="line"> </div><div class="line">&quot;awesome&quot; : true,</div><div class="line"> </div><div class="line">&quot;name&quot; : &quot;Andres&quot;,</div><div class="line"> </div><div class="line">&quot;position&quot; : &quot;Developer&quot;</div><div class="line">  &#125;, &#123;</div><div class="line"> </div><div class="line">&quot;children&quot; : 3,</div><div class="line"> </div><div class="line">&quot;name&quot; : &quot;Michael&quot;,</div><div class="line"> </div><div class="line">&quot;position&quot; : &quot;Developer&quot;</div><div class="line">  &#125; ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">UNWIND $props AS properties</div><div class="line">CREATE (n:Person)</div><div class="line">SET n = properties</div><div class="line">RETURN n</div></pre></td></tr></table></figure></p>
<p><font color="red">2.5.5 查询关系(限定跳数)</font><br>a到b的跳数少于7跳<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(a)-[*..7]-&gt;(b)</div></pre></td></tr></table></figure></p>
<p><font color="red">2.5.6 Match</font><br>匹配关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 不分方向</div><div class="line">--</div><div class="line"># 带有具体关系</div><div class="line">-[r]-</div><div class="line"># 指向关系</div><div class="line">--&gt;</div><div class="line"># 带有具体关系</div><div class="line">-[r]-&gt;</div></pre></td></tr></table></figure></p>
<p>两点之间最短长度的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MATCH (martin:Person &#123; name: &apos;Martin Sheen&apos; &#125;),(oliver:Person &#123; name: &apos;Oliver Stone&apos; &#125;), p =</div><div class="line">shortestPath((martin)-[*..15]-(oliver))</div><div class="line">RETURN p</div></pre></td></tr></table></figure></p>
<p><font color="red">2.5.7 直接从CSV文件中批量插入结点数据</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># CSV文件内容:</div><div class="line">&quot;1&quot;,&quot;ABBA&quot;,&quot;1992&quot;</div><div class="line">&quot;2&quot;,&quot;Roxette&quot;,&quot;1986&quot;</div><div class="line">&quot;3&quot;,&quot;Europe&quot;,&quot;1979&quot;</div><div class="line">&quot;4&quot;,&quot;The Cardigans&quot;,&quot;1992&quot;</div><div class="line"></div><div class="line"># query</div><div class="line">LOAD CSV FROM &apos;&#123;csv-dir&#125;/artists.csv&apos; AS line</div><div class="line">CREATE (:Artist &#123; name: line[1], year: toInt(line[2])&#125;)</div></pre></td></tr></table></figure></p>
<p>当CSV文件包含大量数据时,使用USING PERIODIC COMMIT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">USING PERIODIC COMMIT</div><div class="line">LOAD CSV FROM &apos;&#123;csv-dir&#125;/artists.csv&apos; AS line</div><div class="line">CREATE (:Artist &#123; name: line[1], year: toInt(line[2])&#125;)</div></pre></td></tr></table></figure></p>
<p><font color="red">2.5.7 Set</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 更新属性</div><div class="line">MATCH (peter &#123; name: &apos;Peter&apos; &#125;)</div><div class="line">SET peter += &#123; hungry: TRUE , position: &apos;Entrepreneur&apos; &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 给结点增加标签</div><div class="line">MATCH (n &#123; name: &apos;Stefan&apos; &#125;)</div><div class="line">SET n :German</div><div class="line">RETURN n</div></pre></td></tr></table></figure>
<p><font color="red">2.5.8 Delete</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 删除单节点</div><div class="line">MATCH (n:Useless)</div><div class="line">DELETE n</div><div class="line"></div><div class="line"># 删除一个结点及其所有关系</div><div class="line">MATCH (n &#123; name: &apos;Andres&apos; &#125;)</div><div class="line">DETACH DELETE n</div></pre></td></tr></table></figure></p>
<p><font color="red">2.5.9 Remove</font><br>Remove和Delete不同之处在于,Delete用来删除结点,而Remove用来移除结点的属性和标签.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 移除结点的age属性</div><div class="line">MATCH (n &#123; name: &apos;Peter&apos; &#125;)</div><div class="line">REMOVE n:German</div><div class="line">RETURN n</div></pre></td></tr></table></figure></p>
<p><font color="red">2.5.10 FOREACH</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MATCH p =(begin)-[*]-&gt;(END )</div><div class="line">WHERE begin.name = &apos;A&apos; AND END .name = &apos;D&apos;</div><div class="line">FOREACH (n IN nodes(p)| SET n.marked = TRUE )</div></pre></td></tr></table></figure></p>
<h3 id="3-neo4j-python"><a href="#3-neo4j-python" class="headerlink" title="3.neo4j-python"></a>3.neo4j-python</h3><p>安装驱动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install neo4j-driver==1.1.0</div></pre></td></tr></table></figure></p>
<p>带参更新数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tx.run( &quot;CREATE (person:Person &#123;name: &#123;name&#125;, title: &#123;title&#125;&#125;)&quot;,parameters( &quot;name&quot;, &quot;Arthur&quot;, &quot;title&quot;, &quot;king&quot; ) );</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">result = session.run(&quot;MATCH (weapon:Weapon) WHERE weapon.name CONTAINS &#123;term&#125; &quot;</div><div class="line"> </div><div class="line">&quot;RETURN weapon.name&quot;, &#123;&quot;term&quot;: search_term&#125;)</div></pre></td></tr></table></figure>
<p>保存结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">session = driver.session()</div><div class="line">result = session.run(&quot;MATCH (knight:Person:Knight) WHERE knight.castle = &#123;castle&#125; &quot;</div><div class="line"> </div><div class="line">&quot;RETURN knight.name AS name&quot;, &#123;&quot;castle&quot;: &quot;Camelot&quot;&#125;)</div><div class="line">retained_result = list(result)</div><div class="line">session.close()</div><div class="line">for record in retained_result:</div><div class="line">	print(&quot;%s is a knight of Camelot&quot; % record[&quot;name&quot;])</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/DuncanZhou/2017/05/10/py2neo/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="duncan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww1.sinaimg.cn/large/0060lm7Tgw1fakgrchk2xj303d03dmx4.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Duncan's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Duncan's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/10/py2neo/" itemprop="url">
                  python与neo-4j交互(对py2neo包做的笔记)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-10T22:50:12+08:00">
                2017-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.连接数据库(三种方式相等)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">graph_1 = Graph()</div><div class="line">graph_2 = Graph(host=&quot;localhost&quot;)</div><div class="line">graph_3 = Graph(&quot;http://localhost:7474/db/data&quot;)</div></pre></td></tr></table></figure></p>
<p>2.事务操作<br>a)直接返回结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">graph.data(&quot;MATCH (a:Person) RETURN a.name, a.born LIMIT 4&quot;)</div></pre></td></tr></table></figure></p>
<p>b)以pandas格式返回结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataFrame(graph.data(&quot;MATCH (a:Person) RETURN a.name, a.born LIMIT 4&quot;))</div></pre></td></tr></table></figure></p>
<p>事务操作样例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from py2neo import Graph, Node, Relationship</div><div class="line">g = Graph()</div><div class="line">tx = g.begin()</div><div class="line">a = Node(&quot;Person&quot;, name=&quot;Alice&quot;)</div><div class="line">tx.create(a)</div><div class="line">b = Node(&quot;Person&quot;, name=&quot;Bob&quot;)</div><div class="line">ab = Relationship(a, &quot;KNOWS&quot;, b)</div><div class="line">tx.create(ab)</div><div class="line">tx.commit()</div><div class="line">g.exists(ab)</div></pre></td></tr></table></figure></p>
<p>3.匹配关系<br>查找alice的所有朋友<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for rel in graph.match(start_node=alice,rel_type=&quot;FRIEND&quot;):</div><div class="line">	print(rel.end_node()[&apos;name&apos;])</div></pre></td></tr></table></figure></p>
<p>4.带参数查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from py2neo import Graph</div><div class="line">g = Graph()</div><div class="line"># evaluate()返回结果的第一个值</div><div class="line">g.run(&quot;&quot;MATCH (a) WHERE a.email=&#123;x&#125; RETURN a.name&quot;,x=&quot;bob@acme.com&quot;).evaluate()</div><div class="line">g.run(&quot;&quot;MATCH (a) WHERE a.email=&#123;x&#125; RETURN a.name&quot;,x=&quot;bob@acme.com&quot;).data()</div></pre></td></tr></table></figure></p>
<p>5.NodeSelector使用,可以使用Cypher语言的where部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">from py2neo import Graph,NodeSelector</div><div class="line">graph = Graph()</div><div class="line">selector = NodeSelector(graph)</div><div class="line">slected = selector.select(&quot;Person&quot;,name=&quot;Keanu Reeves&quot;)</div><div class="line">list(selected)</div><div class="line">selected = selector.select(&quot;Person&quot;).where(&quot;_.name =~ &apos;J.*&apos;&quot;,&quot;1960 &lt;= _.born &lt; 1970&quot;)</div><div class="line">list(selected)</div></pre></td></tr></table></figure></p>
<p>6.删除操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 删除所有的</div><div class="line">graph.delete_all()</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/DuncanZhou/2017/05/08/Python-MPI/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="duncan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww1.sinaimg.cn/large/0060lm7Tgw1fakgrchk2xj303d03dmx4.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Duncan's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Duncan's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/08/Python-MPI/" itemprop="url">
                  python-MPI安装命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-08T13:13:21+08:00">
                2017-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="在Ubuntu下安装MPI环境-python环境"><a href="#在Ubuntu下安装MPI环境-python环境" class="headerlink" title="在Ubuntu下安装MPI环境(python环境)"></a>在Ubuntu下安装MPI环境(python环境)</h3><p><font color="red">Step1:</font>安装python环境<br></p>
<p><font color="red">Step2:</font>sudo apt-get install openmpi-bin<br></p>
<p><font color="red">Step3:</font>sudo apt-get install libopenmpi-dev<br></p>
<p><font color="red">Step4:</font>sudo apt-get install python-mpi4py<br></p>
<p><strong>(第三步不要忽略)</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/DuncanZhou/2017/04/26/Personalized Search泛读记录/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="duncan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww1.sinaimg.cn/large/0060lm7Tgw1fakgrchk2xj303d03dmx4.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Duncan's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Duncan's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/26/Personalized Search泛读记录/" itemprop="url">
                  Personalized Search泛读记录
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-26T14:48:27+08:00">
                2017-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Backgournd"><a href="#Backgournd" class="headerlink" title="Backgournd"></a>Backgournd</h3><p>搜索在20年前就已出现在互联网，而如今搜索已经无处不在。传统的搜索像这样，用户给出Query，Query中包含1个或多个关键词，搜索引擎通过关键词去检索返回查询结果。然而，在互联网上存在的资源早已是亿万级，所以仅仅用传统的搜索方法去返回给用户查询结果势必会存在大量用户不需要的结果，根据2007年”Tag recommendations in folksonomies”一文中提出不考虑用户偏好返回的搜索结果中仅有20%-45%是用户想要的，另外,用户所想查找的内容也可能远远不在结果的前列，所以，这类问题的解决需要在传统的搜索方法上考虑context-上下文，即，<br>简要概括:1.用户搜索返回的结果大量是其所不需要的;2.不同的用户提出同一个关键词,搜索引擎返回的结果都是同样的,而不同的用户使用同一个关键词所想搜索的意图其实可能是不同的.<br>将(1)用户的行为、习惯、兴趣/历史搜索结果等等;(2)资源上下文(3)任务上下文等因素考虑进去。</p>
<p>网络个性化用于四类:predicting web navigation, assisting personalization information, personalizing content, and personalizing search results<br>有两类方法:协同过滤和user profiles<br>协同过滤的缺点:这种方法能根据大多数人的兴趣推测什么是流行的,但不能预测某一个用户是否对新的页面是否感兴趣.</p>
<p><strong>1.User Models</strong><br>1.1 可以用来构建用户特征的有<br>a)内容方面:查询的关键词、网页的内容、桌面索引等等<br>b)行为方面:浏览的网页、tag 活动/直接或间接的反馈等<br>c)上下文方面:性别、年龄、地理位置、时间等</p>
<p>1.2 时间上分短期和长期兴趣(将两者结合起来,按时间分配权重)<br>1.2.1长期兴趣偏好建立方式:<br>    行为:具体的查询和URLs<br>    内容:语言模型/主题模型</p>
<p>1.2.2短期兴趣偏好建立方式:<br>    搜索session的queries</p>
<p>1.3 用户分个体还是某类群体</p>
<p><strong><font color="red">Note:</font></strong><br><strong><font size="4">a</font></strong>.在用户model中还需考虑的有长期和短期的兴趣,仅仅根据用户长期的兴趣来推测用户现在想要的搜索结果会有偏差.e.g.一个人之前搜索的”java”都是关于编程语言,但不排除他下一次搜索”java”是要找”java咖啡或者java 岛”.用户的兴趣会改变的.<br><strong><font size="4">b</font></strong>.对用户可profile的信息有:Clickthrough Histories/Queries Histories/搜索过网页的Snippets/收藏过的书签<br><strong><font size="4">c</font></strong>.Domain Ontological:所谓的领域本体（domain-specific ontology）就是对学科概念的一种描述，包括学科中的概念、概念的属性、概念间的关系以及属性和关系的约束。由于知识具有显著的领域特性，所以领域本体能够更为合理而有效地进行知识的表示。<br><strong><font size="4">d</font></strong>.Folksonomy中的challenges:(1)用户标注的tags有很多的同样的拼写,不同意思的单词;有很多同义词;(2)怎么根据tags去对用户偏好建模(Tags聚类/VSM-空间向量模型/领域本体论(有一篇文章中将用户的tags映射到ODP(the Open Directionary Project)-Web topic ontology中))<br>–在Folksonomy中,用户标注的资源都是用户所感兴趣的资源,或者说用户所标注的资源都能代表用户的兴趣偏好;也就是说用户不再仅仅是web资源的消费者,同时用户可以通过承担web的一些任务同时方便其他web用户.(Folksnonomy这样一类系统代表性的有:Flickr.com/Delicious.com/Last.fm)<br><strong><font size="4">e</font></strong>.Clustering:聚类用于两个方面:切分和分层(分级).<br><strong><font size="4">f</font></strong>.<strong>Social Context</strong>:有一些预定义好的值,每个上下文的值都有具体的值.<strong>Verbal Context:</strong>历史查询/点击记录等</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>1.可以入手的方面有三类:user model(long-term &amp; short-term)/query的替换或扩充/resource(web resource)/privacy/evaluation/查询效率<br>2.可以选择的对象有两个:Server端和Client-Side端</p>
<p>用户相关性:<br>1.直接的显示反馈<br>2.隐式地从点击熵获得</p>
<p>用户潜在的意图:<br>1.上下文的元数据<br>    Location/Time/Device</p>
<p>2.过去的行为<br>    当前的session活动/长期的活动和兴趣偏好</p>
<blockquote>
<p>基本的方法：<br>（1）对Query做扩展或替换<br>比如，用户正在浏览的关于汽车的页面，那么当他搜索“轮廓”时，会将Query的关键词添加“汽车”关键词，使返回的结果是用户想要找的汽车轮廓结果。<br>（2）对结果排序<br>根据user profile，进行相似度匹配对结果重新排序。</p>
</blockquote>
<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>1.MovieLens(notations &amp; ratings)<br>2.Delicious.com(bookmarks)<br>3.Flickr(notations)<br>4.DOMZ(ODP)–web search经常使用<br>5.BibSonomy(<a href="http://bibsonomy.org" target="_blank" rel="external">http://bibsonomy.org</a>)<br>6.CiteULike(网页书签数据)</p>
<h3 id="泛读论文时方法总结"><a href="#泛读论文时方法总结" class="headerlink" title="泛读论文时方法总结"></a>泛读论文时方法总结</h3><p>其他方法：<br>1）2002年CIKM中将用户的Query分类<br>2）2003年”Scaling Personalized Web Search”根据用户兴趣给页面分配权重用图来计算，类似PageRank<br>3）2005年WWW”A Personalized Search Engine Based on Web-Snippet Hierarchical Clustering”对网页的Snippet做了聚类然后对结果再根据User Profile对查询结果再排序<br><strong><font color="red">(Snippet指的是网页的标题和摘要)</font></strong><br>4）2005年WWW-“CubeSVD: A Novel Approach to Personalized Web Search”将用户的点击链接历史记录(who click which web page)作为user profile部分辅助查询.通过从点击链接记录数据中发现用户的兴趣和搜索信息的模式.<br>5)2005年CIKM”Implicit User Modeling for Personalized Search”User Model方法,完成了一个客户端查询代理.针对长期兴趣可能会改变的问题,本文中利用即时的搜索上下文和隐式的反馈来user model.<br>隐式的反馈信息有着两类:1)根据之前的查询寻找合适的term去扩展现在的query;2)利用用户已经看过的文档形成摘要来对没有看过的文档重新排序<br>6)2005年WI”Personalized Serach Based on User Search History”根据用户搜索历史对用户profile,利用User Profiles来对查询或者snippets分类,然后再对搜索结果重排序<br>7)2005年WI”Personaliezed Search Results with User Interest Hierarchies Learnt from Bookmarks”建立分层的user profile来对查询结果重新排序.<br>8)2005年DATAK期刊”Category ranking for personalzied search”在ODP分类基础上根据用户profile重新选择一个子图结构分类来personalize 查询结果<br>9)2006年WWW”Automatic Identification of User Interest For Personalized Search”利用用户历史点击记录构建user profile来对查询结果重新排序.<br><strong><font color="blue">补充:2006年SIGKDD”Mining Long-Term Search History to Improve Search Accuracy”挖掘用户长期的搜索历史提出统计的语言模型</font></strong><br>10)2007年WWW”A Large-scale Evaluation and Analysis of Personalized Search Strategies”评价Personalized Search对于传统搜索是否有提高,并且揭示了Click-Based方法优于profile-based方法<br>11)2007年CIS”Personalized Web Search Using User Profile”在Client-Side构建User Profile,然后对用户的Query根据Profile进行扩充使查询更具体,将Query提交给Search Engine.<br>12)2007WWW”Privacy-Enhancing Personalized Web Search”权衡用户隐私和个性化搜索的需要,将用户无结构的个人数据整合成有结构的User Profile<br>13)2007年SIGIR”Privacy Protection in Personalized Search”在个性化搜索时同时保护用户隐私,在Client-Side保护隐私比在Server-Client要好<br>14)2007年WI”Using Personalized Web Search for Enhancing Common Sense and Folksonomy Based Intelligent Search Systems”对于大众分类标签的这样的系统中,用户检索时对于其他用户标注的内容会检索到不相关的内容,本文利用搜索历史和兴趣分类来建立用户偏好<br>15)2008年CIKM”Matching Task Profiles and User Needs in Personalized Web Search”在Client-Side,同时结合用户之前的<strong><font color="green">历史搜索结果</font></strong>和<strong><font color="green>" 当前的session上下文<="" font=""></font></strong>对用户建立不同粒度的profile.同时结合past search results(search histories)和current session context就弥补了只根据用户长期兴趣造成的缺点.<br>16)2008年WWW”Personalized Search and Exploration with MyTag”一篇DEMO完成了这样一个系统,根据flickr,YouTube和del.icio.us多个系统构造用户profile,在用户查询时完成返回多个平台的个性化资源结果.<br>17)2008年SIGIR”The Impact of History Length on Personalized Search”一篇DEMO基于任务研究web search(Task-based即限制了查询的方向,限制了查询任务),研究了搜索历史的长度对personalized search的影响.<br>18)2009年”Cluster Based Personalized Search”着手了两方面:利用文本聚类方法来Personalized Search和新的evaluation准则<br>19)2009年WSDM”Discovering and Using Groups to Improve Personalized Search”由于利用收集的个人信息来User Profile,但是由于通常User的个人信息通常不足够来构建,所以该篇文章利用其他用户来辅助收集用户个人信息.通过Query的相似性groupize一类用户<br><strong><font color="blue">20)2009年TKDE期刊”Evaluating the Effectiveness of Personalized Web Search”测试了五种personalized search算法,提出了新的评价框架来测试是否personalized search对于不同的用户提出不同的queries在不同的搜索上下文中有没有用.(五种测试方法:2种Click-based和3种Topipcal-interest-based);并且,提出了现有的personalized search的缺点:大多数提出的算法都是运用到所有的用户和查询上(对于有些很明确的查询不需要应用personalized;personalization算法的有效性会根据不同的搜索上下文而不同;现有的论文中测试personalized search的算法是基于少量的参与者积累查询数据集,很少有在真是世界中数据集做测试)</font></strong><br><strong><font color="blue">21)2009年CIKM”Personalized Social Search Based on the User’s Social Network”利用用户的三种社会关系:家庭社会关系/相似社会关系/全部的社会关系来建立user profile</font></strong><br><strong><font color="blue">22)2009年CSE”Social Tagging in Query Expansion:a New Way for Personalized Web Search”对于社交网络和协标注系统利用协标注来对Query进行扩展</font></strong><br><strong><font color="blue">23)2009年Konwl Inf syst”Towards a graph-based user profile modeling for a session-based personalized search”提出了利用图结构来user profile</font></strong><br>24)2010年WWW”Anonymizing User Profiles for Personalized Web Search”关于user profile的隐私保护<br>25)2010年”Applying Taxonomic Knowledge and Semantic Collaborative Filtering to Personalized Search: a Bayesian Belief Network based Approach”对于利用查询关键词匹配得到结果的方法而言,有些结果与查询有关而却与查询的关键字术语没有能匹配的结果往往会漏掉.该篇文章为了找出具有权威性的文本,通过语义协同过滤,用贝叶斯信念网络来代表用户的偏好,查询和相关的文本.<br><strong><font color="green">26)2010年CIKM”CiteData:A new multi-faceted dataset for evaluating personalized search performance”现在的personalized search系统使用了用户各种各样的特征数据如:文本超链接/分类标签等,将各种分类方法和社会标注结合起来,随之有分类/PageRank/协同过滤等算法来处理personalized search,但是对于这些方法的评价一直没有合适的数据集,所以该篇文章提出新的评价方法,利用多种多方面的数据来评价personalized search方法的表现.</font></strong><br><strong><font color="blue">27)2010年AMT”Folksonomy-Based Ontological User Interest Profile Modeling and Its Application in Personalized Search”在大众分类系统中,利用用户标注的tags并运用领域本体论来构建用户兴趣偏好</font></strong><br>28)2010年<strong>ICDE</strong>“Personalized Web Search with Location Preferences”文中将用户偏好概念分为了内容概念和位置概念,本文不仅从搜索结果/点击率来构建内容上的兴趣偏好,还考虑了位置概念.<br>29)2010年WIC”Personalized Search based on a User-centered Recommender Engine”提出了将<strong>推荐系统</strong>和Personalized Search结合起来<br><strong><font color="blue">30)2011年CIKM”A Framework for Personalized and Collaborative Clustering of Search Results”根据search results利用Wiki预料来聚类和协同过滤的方法来优化个性化搜索结果.</font></strong><br>30)2011年WEBIST”A Multi-factor Tag-Based Personalized Search”提出了利用用户的tag activity(浏览过的网页和对网页分配的标签)来建立用户的偏好然后再重新排序搜索结果.<br>31)2011年IS的期刊”A personalized search using a  semantic distance measure in a graph-based ranking model”用图结构(映射到ODP上)来表示文本和user profiles,基于语义距离测量来重新对搜索结果排序.<br>32)2011年UMAP”Leveraging Collaborative Filtering to Tag-Based Personalized Search”利用协同过滤的方法通过其他相似用户计算用户的潜在兴趣偏好,通过相似物品来构建物品的潜在tags.<br><strong><font color="blue">33)2011年CSC”Modeling User’s Preference in Folksonomy for Personalized Search”在大众分类系统利用标签聚类来构建user profile</font></strong><br>34)2011年Canadian AI”Normal Distribution Re-Weighting for Personalized Web Search”根据term的频率建立向量构建profile,但是同时重新对vector建立权重.因为频率大小对profile的影响是不一样的,其中,比较注重的是Mid-frequency.<br>35)2011年WWW”Personalized Search on Flickr based on Searcher’s Preference Prediction”一篇DEMO,基于Flickr系统根据用户的朋友的兴趣偏好和聚类方法来预测该用户所要找的图片.(e.g.用户搜索”长城”,返回118147张照片结果,但是,他/她所需要或想要的是哪一张或那几张需要自己去从中挑选)<br><strong><font color="blue">36)2011年FSKD”User Profile for Personalized Web Search”利用三种机器学习方法(Rocchio/K-Nearest Neighbors/SVM)来构建user profiles</font></strong><br>37)2012年ICCCI”Construction of Semantic User Profile for Personalized Web Search”完成这样一个系统,让用户输入用户名和邮件地址后从网页抓取和邮件地址相关的信息来构建user profile(使用VSM)(依据ODP).<br>38)2012年APWeb”Context-Aware Personalized Search Based on User and Resource Profiles in Folksonomies”指出了之前运用于Folksonomy系统中建立VSM后TF-IDF和BM25方法的不合理之处.<br><strong><font color="blue">39)2012年Information Systems期刊”Folksonomy-based personalized search and ranking in social media services”同时利用面向用户的tags和面向items的tags构建模型,构建user-tag矩阵/user-item矩阵/tag-item矩阵;对于查询的term没有出现在标注中的情况也能够对结果重新排序</font></strong><br>40)2012年”Multilingual User Modeling for Personalized Reranking of Multilingual Web Search Results”用多语言来构建用户模型.<br>41)2012年ADMA”Personalized Diversity Search Based on User’s Social Relationships”针对搜索引擎由于不能领会用户潜在的意图和兴趣偏好,所以不能返回给用户精确/充足,且伴随有累赘的结果.现有的方法有返回多样性的结果来满足大部分用户,并且统一地运用到所有的用户和查询中,返回的结果通常返回的是大部分用户的需求,对于某个用户的具体需求并没有被考虑进去.本文将多样性搜索和个性化搜索结合来使搜索结果对于群体和某个用户来说更加精确.<br><strong><font color="blue">42)2012年SIGMOD”Taagle:Efficient,Personalized Search in Collaborative Tagging Networks”用户带有在社交网络中的权值,items带有用户的关键词标注,用户用某一个tags来搜索返回Top-k个结果</font></strong><br>43)2013年SIGMOD”Efficient Ad-hoc Search for Personalized PageRank”对PPR做了改进<br><strong><font color="blue">44)2013年WWW”Enhancing Personalized Search by Mining and Modeling Task Behavior”提出之前在Personalized Search中都是比较依赖和用户历史查询记录相关信息,对于新的查询可能会无所适从;本文提出了Task-based(基于URLs)的方法,通过在历史搜索日志中挖掘出提出过和当前用户任务相关的用户,利用他们的on-task行为来提升web pages的排序.并将算法和Query-based进行对比</font></strong><br><strong><font color="blue">45)2013年(LiQing)WI-IAT”Finding Dominating Set from Verbal Contextual Graph for Persoanlized Search in Folksonomy”对于去挖掘用户潜在的意图和兴趣偏好,基于上下文的信息是不可或缺的,在社会语言学中上下文中分为Verbal Context(queries历史/点击历史数据)和social context(mood/weather/time).通过对比了social context之后,作者选用了verbal context语言模型,verbal context模型用图结构构造,并将重要的节点区别出来.</font></strong><br><strong><font color="blue">46)2013年SIGKDD一篇DEMO”LAICOS:An Open Source Platform Personalized Social Web Search”1.利用了文本内容来建立social context2.和之前方法一样也用了对query进行扩展的方法.当用户提出一个query,系统会根据用户experience匹配query,同时,系统还会根据其他提出过相似查询的用户来返回相似的文档</font></strong><br><strong><font color="blue">47)2013年CIKM”Personalized Models of Search Satisfaction”这篇文章通过区分不同用户的搜索行为来建立用户的满意度,从而使个性化搜索更为准确.(依赖于点击数据)</font></strong><br>48)2013年SIGIR”Personalized Ranking Model Adaptation for Web Search”针对之前搜索引擎对所有的用户都运用单一的排序模型而提出了新的排序模型(通过一系列的线性转化,缩放或者转变)<br>49)2013年ICCCSA”Personalized Semantic Search Using ODP:A Sutdy Case in Academic Domain”将文本大致分类到相应的实体ODP来完成语义搜索<br>50)2013年SIGIR”SoPRa: A New Social Personalized Ranking Function for Improving Web Search”提出了新的搜索结果等级排序函数<br>51)201年SIGIR”Using Social Annotations to Enhance Document Representation for Personalized Search”基于用户查询过的网页,不仅仅基于该用户对其的标注,而且考虑其他用户的标注.因为如果只考虑该用户的标注存在两个问题:1)忽略了他没有标注的页面2)分配的等级分数不合理<br>52)2014年WSDM”Adapting Deep RankNet for Personalized Search”:RankNet被广泛地应用在web搜索任务中,但是很少有应用在Personalized Search中.本文利用5层深度神经网络来构造RankNet运用于Personalized Search中.<br>53)2014年KDD”Personalized Search Result Diversification via Structured Learning”利用有监督学习来解决搜索结果个性化多样性的问题,既保持结果的多样性,同时结合用户的兴趣偏好<br><strong><font color="blue">54)2015年”Adaptive and Multiple Interest-aware User Profiles for Personalized Search in Folksonomy:A Simple but Effective Graph-based Profiling Model”基于图结构利用社会标注的tags构造自适应的且融合多种用户兴趣偏好的user profiles.</font></strong><br>55)2015年WWW”An Optimization Framework for Weighting Implicit Relevance Labels for Personalized Web Search”提出了之前给web document分配权重的不合理之处,另外重新提出了personalized ranking算法.<br>56)2015年”Real Time Personalized Search on Social Networks”提出了在社交网络平台中两个特点1)频繁的内容更新2)小社区群体;而现有的搜索算法都还不能解决这样两个问题,本文提出了实时的personalized top-k查询(等级排序算法融合了时间/社会相关性/文本相似性).<strong>加入了时间因素</strong><br>57)2016年SIGKDD”How to Get Them a Dream Job”主要针对Job Personalized Search.<br>58)2016年SIGIR一篇DEMO”Learning to Rank Personalized Search Results in Professional Networks”在领英中提出新的结果等级排序算法.<br>59)2016年Neurocomputing”Personalized search for social media via dominating verbal context”<strong>Qing Li</strong>同之前篇<br>60)2016年Knowledge-Based Systems”Preference recmmendation for personalized search”综合之前的user profiles模型,本文指出使用比较广泛有一个CP-nets模型,不仅能简明地表达用户定性的兴趣偏好,而且很好地定义了用户偏好的范围.现在很多基于CP-nets的搜索系统都是假设用户之前已经定义好他们的兴趣偏好范围,但是在生活中这并不现实.本文的工作一方面利用不完全的CP-nets,另一方面利用协同过滤来弥补CP-nets的不足.还有一方面,本文提出偏好推荐模式来弥补CP-nets的不足.<br>61)2016年”Topic Model based Privacy Protection in Personalized Web Search”本文在保持搜索引擎个性化的同时,通过在用户查询日志中加入控制噪声来保护用户隐私.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/DuncanZhou/2017/04/05/Exploring Folksonomy for Personalized Search/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="duncan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww1.sinaimg.cn/large/0060lm7Tgw1fakgrchk2xj303d03dmx4.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Duncan's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Duncan's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/05/Exploring Folksonomy for Personalized Search/" itemprop="url">
                  Personalized Search论文阅读笔记-08年SIGIR
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-05T20:55:40+08:00">
                2017-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="论文题目"><a href="#论文题目" class="headerlink" title="论文题目"></a>论文题目</h2><h3 id="Exploring-Folksonomy-for-Personalized-Search"><a href="#Exploring-Folksonomy-for-Personalized-Search" class="headerlink" title="Exploring Folksonomy for Personalized Search"></a>Exploring Folksonomy for Personalized Search</h3><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><p><strong>Folksonomy:</strong></p>
<blockquote>
<p>该单词由folk和taxonomy组成，folk是口语中伙伴的意思，taxonomy是分类方法的意思，该词用来表示现在存在的大众分类的一种现象。目前许多应用允许用户上传资源时选择标签标注该资源。现有的应用如flickr和dogear。</p>
</blockquote>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>对于这样允许大众分类的应用，如何满足用户在搜索时尽可能准确地返回用户所需要的资源是一个有意思的问题。因为如果像传统的搜索方法仅通过查询关键词去匹配搜索结果，返回的结果可能会不满足用户的初衷。而且，不同的用户在搜索不同的资源时有可能会使用同样的关键词，比如，爱好运动和爱好喝咖啡的用户在搜索杯子的时候使用的关键词都可能是“杯子”，而返回的结果对于爱好运动的用户来说应该尽可能是运动型杯子，对于爱好喝咖啡的用户来说应该尽可能是咖啡杯子。所以，这里的问题都归结于Personalized Search。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>根据之前的工作，解决这样问题的方法有两类:<font color="red">Query Refinement</font>和<font color="red">Result Processing</font> </p>
<blockquote>
<p>1)对于查询术语进行替换和扩展，替换成其他的术语或者用其他的术语来填充<br>2)对查询返回的结果再排序或者结果聚类等方法<br>使用较为普遍的是Result Processing，该篇论文中使用的也是第二种方法。</p>
</blockquote>
<p>本文中提出的方法分为三个步骤：<br>1)Query中的terms先求结果排序得到Ranklist<br>2)通过User的Interest Vector和资源的Topic Vector求相似性得到Ranklist<br>3)聚合两个list得到最终的Ranklist<br>(具体在实验过程中，为了提高效率，第二步求Ranklist只对第一步中的前N个再去求排序)</p>
<h2 id="Details-Of-Methods"><a href="#Details-Of-Methods" class="headerlink" title="Details-Of-Methods"></a>Details-Of-Methods</h2><p><font color="red"><strong>Step1：</strong></font><br>对于Query中的terms去求资源排序，本文中采用<strong>BM25</strong>和<strong>Language Model for IR(LMIR)</strong>这两种文本检索模型。<br>先通过基本的文本检索去得到第一步的Ranklist。</p>
<p><font color="red"><strong>Step2：</strong></font><br>第二步是本文的核心。关键在于建立Topic Space,因为建立了Topic Space后，才能对用户建立兴趣向量，才能对资源建立主题向量，然后再去计算两者之间的相似性。</p>
<p>1.本文中的主题空间使用了Folksonomy的方法，以标注的tag作为向量的每一维，每个维的值的计算方法可以通过tfidf或者BM25来计算，从而构成用户和资源的兴趣和topic向量。<br>此外，本文中以ODP分好类的web pages的topic space作为baseline方法。</p>
<p>2.当分别构建好用户和资源的向量后，本文通过类PageRank算法来迭代形成最终的用户和资源的矩阵。R矩阵行代表用户，列代表兴趣。T矩阵行代表资源，列代表topic。</p>
<p><font color="red"><strong>Step3：</strong></font><br>本文中聚合两个list的方法是通过简单的WBF方法去得到最终的Ranklist</p>
<h2 id="Evaluation-Methods"><a href="#Evaluation-Methods" class="headerlink" title="Evaluation-Methods"></a>Evaluation-Methods</h2><p>本文基于一个假设：用户收藏过或标注过的资源即为用户相关资源，以此来通过检索评价标准来评价Personalized Search。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/DuncanZhou/2017/03/17/Personalized Search by Tag-based in Collaborative Tagging Systems/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="duncan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww1.sinaimg.cn/large/0060lm7Tgw1fakgrchk2xj303d03dmx4.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Duncan's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Duncan's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/Personalized Search by Tag-based in Collaborative Tagging Systems/" itemprop="url">
                  Personalized Search论文阅读笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-17T21:55:43+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="论文题目"><a href="#论文题目" class="headerlink" title="论文题目"></a>论文题目</h2><h3 id="Personalized-Search-by-Tag-based-User-Profiling-and-Resource-Profile-in-Collaborative-Tagging-Systems"><a href="#Personalized-Search-by-Tag-based-User-Profiling-and-Resource-Profile-in-Collaborative-Tagging-Systems" class="headerlink" title="Personalized Search by Tag-based User Profiling and Resource Profile in Collaborative Tagging Systems"></a>Personalized Search by Tag-based User Profiling and Resource Profile in Collaborative Tagging Systems</h3><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><blockquote>
<p><strong>Collaboative Tagging Systems</strong>:协标签系统，类似于YouTube、Flickr这样一类系统，允许用户使用标签对资源进行标注，而得出用户的标签；所以，用户具有标签，资源也有标签，这样称为协同标签。</p>
<p><strong>folksonomy</strong>:大众分类的。如上所说的一些系统中允许用户去标注资源，即，利用大众的力量去分类资源。</p>
<p><strong>personalized search</strong>:个性化搜索，在返回和查询相关的结果时不仅考虑和搜索的关键词相关，并且考虑用户的profile(偏好)。</p>
</blockquote>
<h2 id="About-this-paper"><a href="#About-this-paper" class="headerlink" title="About this paper"></a>About this paper</h2><p>论文中首先总结了之前的工作中对用户和资源的profile构建的方法，用户和资源的profile的tag的权重计算方法有TF、TF-IDF、BM25，以及用户兴趣和资源相似性的计算方法，但这些方法都存在一定的局限性。<br><strong>TF方法</strong>：对于标注比较频繁或者比较活跃的用户，经常使用某些tag标注。如果使用TF计算tag的权重，那么，对于不经常标注资源的用户，其偏好的标签权重必定比活跃的用户tag小很多。</p>
<p><font color="green">举个例子:</font></p>
<blockquote>
<p>Tom = {(tag1:300;tag2:200;tag3:280)}; Jerry = {(tag1:50;tag2:30;tag3:10)} 对于，Tom和Jerry来说，tag1都是其偏好的，但是如果以TF来计算，tag1对于Tom的偏好程度是大于Jerry的，而其实，tag1对Jerry是更为感兴趣的。同理，对于资源标签权重计算方法也存在相似问题。</p>
</blockquote>
<p><strong>TF-IDF方法</strong>：这里为TF-IDF的演变版，TF-IUF和TF-IRF。TF-IDF用来表示一个tag能否表示该实体的程度，同理，TF-IUF和TF-IRF表示一个标签能否表示该用户和资源。但是，这里存在的问题是，标签的权值并不能表示用户对于该标签的偏好程度。</p>
<p><font color="green">举个例子:</font></p>
<blockquote>
<p>Tom的标签使用频率如下:[tag1:500;tag2:400;…;tagn:1]。如果使用TF-IDF方法来计算标签权重，那么，tagn的TF-IDF权重是最大的，但是，tagn并不是用户最感兴趣的。同理，对于资源标签权重计算方法也存在相似问题。</p>
</blockquote>
<p><strong>BM25</strong>:BM25方法是以TF和TF-IDF的值作为变量，所以BM25方法也存在以上的局限性。</p>
<p><strong>用户兴趣与资源相似性计算方法</strong>:一般计算该相似度采用的方法是余弦相似性等相似性计算法方法，这存在一些问题。因为现在用户的标签的权值代表的是用户对该tag的感兴趣程度，而不是与目标资源的相关程度，所以用一般相似性计算方法是不合理的。</p>
<p><font color="green">举个例子:</font></p>
<blockquote>
<p>Resource1 = {(tag1:0.9;tag2:0.95;tag3:0.85)}; Resource2 = {(tag1:0.9;tag2:0.1;tag3:0.01)}; User = {(tag1:0.8;tag2:0.5;…;tag3:0.25)}。如果用一般方法计算相似度，那么R1相似性小于R2，而与用户偏好相似的更多是R1。是因为用户对tag1，tag2，tag3都是偏好的，而R2只是对tag1更符合一些。</p>
</blockquote>
<p>所以，基于以上方法的不合理之处，该论文提出了计算user和resource标签权值及计算用户兴趣和资源相关性的方法。</p>
<h2 id="论文提出的方法"><a href="#论文提出的方法" class="headerlink" title="论文提出的方法"></a>论文提出的方法</h2><h3 id="User-Profiles-Modeling"><a href="#User-Profiles-Modeling" class="headerlink" title="User Profiles Modeling"></a>User Profiles Modeling</h3><blockquote>
<p>某用户中标签的权值 = 该标签被用来标注的次数 / 该用户标签总标注次数</p>
</blockquote>
<h3 id="Resources-Profiles-Modeling"><a href="#Resources-Profiles-Modeling" class="headerlink" title="Resources Profiles Modeling"></a>Resources Profiles Modeling</h3><blockquote>
<p>某资源中标签的权值 = 使用该标签标注该资源的用户数 / 标注该资源的总用户数</p>
</blockquote>
<h3 id="Personalized-Search"><a href="#Personalized-Search" class="headerlink" title="Personalized Search"></a>Personalized Search</h3><p>分为查询相似性计算和用户兴趣与查询相似性计算。相关公式见论文。<br>最后，将两个相似性分数融合得到相似性分数。</p>
<h2 id="实验结果准确性度量标准"><a href="#实验结果准确性度量标准" class="headerlink" title="实验结果准确性度量标准"></a>实验结果准确性度量标准</h2><p>数据集：MovieLens数据集和该论文自己的一个demo系统。</p>
<p><font color="red">1.标准1</font>:imp = 1 / rp - 1 / rb;rp为新方法对目标资源的等级，rb为baseline方法对目标资源的等级。</p>
<p><font color="red">2.标准2</font>:HR：命中率计算方法</p>
<p><font color="red">3.标准3</font>:MRR：平均倒数评级 </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/DuncanZhou/2016/12/15/BackTrackingNote/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="duncan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww1.sinaimg.cn/large/0060lm7Tgw1fakgrchk2xj303d03dmx4.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Duncan's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Duncan's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/15/BackTrackingNote/" itemprop="url">
                  回溯法笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-15T12:32:41+08:00">
                2016-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="BackTracking-Algorithm-Notes"><a href="#BackTracking-Algorithm-Notes" class="headerlink" title="BackTracking Algorithm Notes"></a>BackTracking Algorithm Notes</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><blockquote>
<p>在那些涉及寻找一组解的问题或者求满足某些约束条件的最优解的问题中，有许多问题可以用回溯法来求解。</p>
</blockquote>
<p>为了应用回溯法，所要求的解必须能表示成一个n-元组（x1,x2,…,xn）,其中xi是取自某个有穷集Si。通常，所求解的问题需要求取一个使某一规范函数P(x1,…,xn)取极大值（或取极小值或满足该规范函数条件）的向量。有时还要找出满足规范函数P的所有向量。</p>
<h2 id="2-基本思想"><a href="#2-基本思想" class="headerlink" title="2.基本思想"></a>2.基本思想</h2><blockquote>
<p>不断地用修改过的规范函数（或限界函数）Pi(x1,…,xn)去测试正在构造中的n-元组的部分向量(x1,…,xn)，看其是否可能导致最优解，如果不能，那么将可能要测试的其余向量略去，就是剪枝。</p>
</blockquote>
<p>约束条件分为两类：显式约束和隐式约束。显示约束是限定每个x只从一个给定的集合上取值。隐式约束描述了xi必须彼此相关的情况，规定解空间中那些实际上满足规范函数的元组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Algorithm backTracking</div><div class="line">procedure PBACKTRACK(k)</div><div class="line">//此算法是对回溯法抽象地递归描述。进入算法时，解向量X(1:n)的前k-1个分量X(1),...,X(k-1)已赋值</div><div class="line">	global n,X(1:n)</div><div class="line">	for 满足下式的每个X(k)</div><div class="line">		X(k) 属于 T(X(1),...,X(k-1)) and B(X(1),...,X(k)) = True do</div><div class="line">		if (X(1),...,X(k)) 是一条已抵达答案结点的路径 then</div><div class="line">			print (X(1),...,X(k))</div><div class="line">		endif</div><div class="line">	call PBACKTRACK(k + 1)</div><div class="line">	repeat</div><div class="line">end PBACKTRACK</div></pre></td></tr></table></figure></p>
<h2 id="3-代表性的问题"><a href="#3-代表性的问题" class="headerlink" title="3.代表性的问题"></a>3.代表性的问题</h2><h3 id="a、n-queen问题"><a href="#a、n-queen问题" class="headerlink" title="a、n-queen问题"></a>a、n-queen问题</h3><p>有关n后问题的定义自行查阅，这里不给出解释。</p>
<p><font color="green" style="font-weight: bold;"><em>解决思路</em></font><br>假定皇后i将放在行i上，因此，8皇后问题可以表示出8-元组(x1,x2,…,x8)，其中xi是放置皇后i所在的列号。隐式约束条件：1）没有两个xi可以相同；2）没有两个皇后可以在同一条对角线<br>假设两个皇后在(i,j)和(k,l)位置，则在同在对角线公式为abs(j-l) = abs(i-k)。即，在PLACE函数中可用此公式来判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">procedure NQ(k)</div><div class="line">//X(1),...,X(k-1)已赋值，求X(k),...,X(n)</div><div class="line">	global X(1:n)</div><div class="line">	X(k) = 1</div><div class="line">	while X(k) &lt;= n do</div><div class="line">	//PLACE为检测第k个皇后是否满足约束条件</div><div class="line">		if PLACE(k) then</div><div class="line">			if k = n then </div><div class="line">				print (X(1),...,X(n))</div><div class="line">			else</div><div class="line">			//继续生成</div><div class="line">				NQ(k + 1)</div><div class="line">			endif</div><div class="line">		endif</div><div class="line">		X(k) = X(k) + 1</div><div class="line">	repeat</div><div class="line">end NQ</div></pre></td></tr></table></figure>
<h3 id="b、子集和数问题"><a href="#b、子集和数问题" class="headerlink" title="b、子集和数问题"></a>b、子集和数问题</h3><blockquote>
<p>定义：已知n+1个正数：Wi,1&lt;=i&lt;=n和M。要求找出Wi的和数为M的所有子集。例如，若n=4，(W1,W2,W3,W4)=(11,13,24,7),M=31，则满足要求的子集是(11,13,7)和(24,7)。值得指出的是，通过给出其和数为M的那些Wi的下标来表示解向量比直接用这些Wi表示解向量更为方便。因此这个解向量由(1,2,4)和(3,4)表示。</p>
</blockquote>
<p>显示约束条件要求Xi在1~n之间。隐式约束条件则是要求没有两个Xi是相同的且相应的Wi的和数是M。(为了避免产生同一个子集重复的情况,如(1,4,2)和(1,2,4))，附加另一个隐式约束条件:Xi+1大于Xi,i在1~n之间。</p>
<p><font color="green" style="font-weight: bold;"><em>解决思路</em></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//current代表当前集合中已有和，k表示当前判断的第k个元素，rest代表集合中剩余元素之和</div><div class="line">public void sumOfsubset(int current,int k,int rest)&#123;</div><div class="line">    //先生成左儿子,w[k]加入</div><div class="line">    flag[k] = 1;</div><div class="line">    if(current + w[k] == M)&#123;</div><div class="line">        System.out.print(&quot;&#123;\t&quot;);</div><div class="line">        //子集找到，输出</div><div class="line">        print(k);</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">    else if(current + w[k] + w[k + 1] &lt;= M)</div><div class="line">        sumOfsubset(current + w[k],k + 1,rest - w[k]);</div><div class="line">    //生成右儿子,w[k]不加入</div><div class="line">    if((current + rest - w[k] &gt;= M) &amp;&amp; (current + w[k + 1] &lt;= M))&#123;</div><div class="line">        flag[k] = 0;</div><div class="line">        sumOfsubset(current,k + 1,rest - w[k]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="c、图的着色"><a href="#c、图的着色" class="headerlink" title="c、图的着色"></a>c、图的着色</h3><blockquote>
<p>定义：已知一个图G和m&gt;0种颜色，在只准使用这m种颜色对G的结点着色的情况下，是否能使图中任何相邻的两个结点都具有不同的颜色。这个问题称为m-着色判定问题。</p>
</blockquote>
<p><font color="green" style="font-weight: bold;"><em>解决思路</em></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">   	procedure MCOLORING(k)</div><div class="line">	global integer m,n,X(1:n),boolean Graph(1:n,1:n)</div><div class="line">	integer k</div><div class="line">	loop</div><div class="line">		//给第k个结点赋值颜色</div><div class="line">		call NextValue(k)</div><div class="line">		if X(k) = 0 then</div><div class="line">			exit</div><div class="line">		endif</div><div class="line">		if k = n then</div><div class="line">			print(X)</div><div class="line">		else</div><div class="line">			call MCOLORING(k + 1)</div><div class="line">		endif</div><div class="line">	repeat</div><div class="line">end MCOLORING</div></pre></td></tr></table></figure></p>
<h3 id="d、哈密顿环"><a href="#d、哈密顿环" class="headerlink" title="d、哈密顿环"></a>d、哈密顿环</h3><blockquote>
<p>定义：一个哈密顿环是一条沿着图G的n条边环行的路径，它访问每个结点一次并且返回到它的开始位置。</p>
</blockquote>
<h3 id="e、0-1背包问题"><a href="#e、0-1背包问题" class="headerlink" title="e、0/1背包问题"></a>e、0/1背包问题</h3><p>定义不解释，这个问题解决的方案很多，可以用动归、贪心算法，这里使用回溯法求解。<br>代码如下：</p>
<p><font color="green" style="font-weight: bold;"><em>解决思路</em></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">package Chapter8;</div><div class="line">//Created by duncan on 16-12-14.</div><div class="line">public class BPByBackTrack &#123;</div><div class="line">    int bestvalue = 0;</div><div class="line">    int[] lastfalg;</div><div class="line">    public void swap(int[] x,int m,int n)&#123;</div><div class="line">        int temp;</div><div class="line">        temp = x[m];</div><div class="line">        x[m] = x[n];</div><div class="line">        x[n] = temp;</div><div class="line">    &#125;</div><div class="line">    //先将物品效益和重量按照P/W的大小非递减排序,p和w都从1开始存储</div><div class="line">    public void sort(int[] p,int[] w)&#123;</div><div class="line">        int len = p.length -1 ;</div><div class="line">        for(int i = 1; i &lt;= len; i++)&#123;</div><div class="line">            for(int j = 1; j &lt;= len - i; j++)&#123;</div><div class="line">                    if(((float)p[j] / w[j]) &gt; ((float)p[j + 1] / w[j + 1]))&#123;</div><div class="line">                        swap(p,j,j + 1);</div><div class="line">                        swap(w,j,j + 1);</div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //限界函数,k为上次去掉的物品，M为背包容量,currentp为当前背包中效益值，currentw为背包中当前重量，返回值为当前最大值上限</div><div class="line">    public int Bound(int[] p,int[] w,int k,int M,int currentp,int currentw)&#123;</div><div class="line">        int tempp = currentp,tempw = currentw;</div><div class="line">        int len = p.length - 1;</div><div class="line">        for(int i = k + 1; i &lt;= len; i++)&#123;</div><div class="line">            tempw += w[i];</div><div class="line">            if(tempw &lt; M)</div><div class="line">                tempp += p[i];</div><div class="line">            else</div><div class="line">                return (tempp + (1 - (tempw - M) / w[i] * p[i]));</div><div class="line">        &#125;</div><div class="line">        return tempp;</div><div class="line">    &#125;</div><div class="line">    //回溯法求解背包问题,p,w为效益值和重量数组，M为背包容量，k为当前处理的物品，flag为记录物品放或不放的标志数组,currentp为当前效益，currentw为当前重量</div><div class="line">    public void BKNAPBT(int[] p, int[] w,int M,int k,int[] flag,int currentp,int currentw)&#123;</div><div class="line">        int n = p.length - 1;</div><div class="line">        if(k &gt; n)&#123;</div><div class="line">                if(currentp &gt; bestvalue) &#123;</div><div class="line">                    bestvalue = currentp;</div><div class="line">                    lastfalg = flag.clone();</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            //进入左子树</div><div class="line">            if(currentw + w[k] &lt;= M)</div><div class="line">            &#123;</div><div class="line">                flag[k] = 1;</div><div class="line">                BKNAPBT(p,w,M,k + 1,flag,currentp + p[k],w[k] + currentw);</div><div class="line">            &#125;</div><div class="line">            //进入右子树前先判断右子树的最大上限是否能够比当前最优值大，如果没有则减去右子树</div><div class="line">            if(Bound(p,w,k,M,currentp,currentw) &gt;= currentp) &#123;</div><div class="line">                flag[k] = 0;</div><div class="line">                BKNAPBT(p, w, M, k + 1, flag, currentp, currentw);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void print(int[] p, int[] w)&#123;</div><div class="line">        int len = p.length -1;</div><div class="line">        int m = 0,v = 0;</div><div class="line">        System.out.println(&quot;\n最终放入背包的物品的价值为:&quot;);</div><div class="line">        for(int i = 1; i &lt;= len; i++)&#123;</div><div class="line">            if(lastfalg[i] == 1) &#123;</div><div class="line">                m += w[i];</div><div class="line">                v += p[i];</div><div class="line">                System.out.print(p[i] + &quot; &quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;\n\n最终重量为：&quot; + m);</div><div class="line">        System.out.println(&quot;\n最优解价值为:&quot; + v);</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int m = 0,M = 110;</div><div class="line">        BPByBackTrack bp = new BPByBackTrack();</div><div class="line">        int[] w = &#123;0,1,11,21,23,33,43,45,55&#125;;</div><div class="line">        int[] p = &#123;0,11,21,31,33,43,53,55,65&#125;;</div><div class="line">        int[] flag = &#123;0,0,0,0,0,0,0,0,0&#125;;</div><div class="line">        System.out.println(&quot;物品价值为&quot;);</div><div class="line">        for(int i = 1 ; i &lt;= p.length -1 ;i++)&#123;</div><div class="line">            System.out.print(p[i] + &quot;\t&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;\n物品重量为&quot;);</div><div class="line">        for(int i = 1 ; i &lt;= p.length -1 ;i++)&#123;</div><div class="line">            System.out.print(w[i] + &quot;\t&quot;);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">        bp.sort(p,w);</div><div class="line">        bp.BKNAPBT(p,w,M,1,flag,0,0);</div><div class="line">        System.out.println(&quot;背包容量为:&quot; + M);</div><div class="line">        bp.print(p,w);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/DuncanZhou/2016/12/14/SVM(Extension)/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="duncan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww1.sinaimg.cn/large/0060lm7Tgw1fakgrchk2xj303d03dmx4.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Duncan's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Duncan's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/14/SVM(Extension)/" itemprop="url">
                  支持向量机(Support Vector Machine)学习（补充）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-14T10:17:10+08:00">
                2016-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SMO算法-Sequential-Minimal-Optimization"><a href="#SMO算法-Sequential-Minimal-Optimization" class="headerlink" title="SMO算法(Sequential Minimal Optimization)"></a>SMO算法(Sequential Minimal Optimization)</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><blockquote>
<p>SMO算法用于训练SVM，将大优化问题分解为多个小优化问题。这些小优化问题往往很容易求解，并且对它们进行顺序求解的结构与将它们作为整体来求解的结果是完全一致。</p>
</blockquote>
<h2 id="2-目标及原理"><a href="#2-目标及原理" class="headerlink" title="2.目标及原理"></a>2.目标及原理</h2><blockquote>
<p>SMO算法的工作目标是求出一系列alpha和b,一旦求出了这些alpha，就能求出权重向量w。</p>
<p>每次循环中选择两个alpha进行优化处理。一旦找到一对合适的alpha，那么就增大其中一个同时减少另一个。这里所谓的“合适”就是指两个alpha必须要符合一定的条件，条件之一就是这两个alpha必须在间隔边界之外，而其第二个条件则是这两个alpha还没有进行过区间化处理或者不在边界上。</p>
</blockquote>
<h2 id="3-调参"><a href="#3-调参" class="headerlink" title="3.调参"></a>3.调参</h2><blockquote>
<p>SVM中有两个参数<font color="red">C</font>和<font color="red">K1</font>，其中C是惩罚系数，即对误差的宽容度。C越高，说明越不能容忍出误差，容易过拟合。C越小，容易欠拟合。</p>
<p>k1是参数是RBF函数作为核函数后，该函数自带的一个参数，隐含的决定了数据映射到新的特征空间后的分布，k1越大，支持向量越少，k1越小，支持向量越多。支持向量的个数影响训练与预测的速度。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ww1.sinaimg.cn/large/0060lm7Tgw1fakgrchk2xj303d03dmx4.jpg"
               alt="duncan" />
          <p class="site-author-name" itemprop="name">duncan</p>
          <p class="site-description motion-element" itemprop="description">write something useful</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">duncan</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
